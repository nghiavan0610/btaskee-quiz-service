// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type QuestionType string

const (
	QuestionTypeSingleChoice   QuestionType = "single_choice"
	QuestionTypeMultipleChoice QuestionType = "multiple_choice"
	QuestionTypeTextInput      QuestionType = "text_input"
)

func (e *QuestionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuestionType(s)
	case string:
		*e = QuestionType(s)
	default:
		return fmt.Errorf("unsupported scan type for QuestionType: %T", src)
	}
	return nil
}

type NullQuestionType struct {
	QuestionType QuestionType `json:"question_type"`
	Valid        bool         `json:"valid"` // Valid is true if QuestionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuestionType) Scan(value interface{}) error {
	if value == nil {
		ns.QuestionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuestionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuestionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuestionType), nil
}

func (e QuestionType) Valid() bool {
	switch e {
	case QuestionTypeSingleChoice,
		QuestionTypeMultipleChoice,
		QuestionTypeTextInput:
		return true
	}
	return false
}

type QuizVisibility string

const (
	QuizVisibilityPrivate   QuizVisibility = "private"
	QuizVisibilityPublished QuizVisibility = "published"
)

func (e *QuizVisibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuizVisibility(s)
	case string:
		*e = QuizVisibility(s)
	default:
		return fmt.Errorf("unsupported scan type for QuizVisibility: %T", src)
	}
	return nil
}

type NullQuizVisibility struct {
	QuizVisibility QuizVisibility `json:"quiz_visibility"`
	Valid          bool           `json:"valid"` // Valid is true if QuizVisibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuizVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.QuizVisibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuizVisibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuizVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuizVisibility), nil
}

func (e QuizVisibility) Valid() bool {
	switch e {
	case QuizVisibilityPrivate,
		QuizVisibilityPublished:
		return true
	}
	return false
}

type SessionStatus string

const (
	SessionStatusWaiting   SessionStatus = "waiting"
	SessionStatusActive    SessionStatus = "active"
	SessionStatusCompleted SessionStatus = "completed"
	SessionStatusCancelled SessionStatus = "cancelled"
)

func (e *SessionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SessionStatus(s)
	case string:
		*e = SessionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SessionStatus: %T", src)
	}
	return nil
}

type NullSessionStatus struct {
	SessionStatus SessionStatus `json:"session_status"`
	Valid         bool          `json:"valid"` // Valid is true if SessionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSessionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SessionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SessionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSessionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SessionStatus), nil
}

func (e SessionStatus) Valid() bool {
	switch e {
	case SessionStatusWaiting,
		SessionStatusActive,
		SessionStatusCompleted,
		SessionStatusCancelled:
		return true
	}
	return false
}

type TimeLimitType string

const (
	TimeLimitType5  TimeLimitType = "5"
	TimeLimitType10 TimeLimitType = "10"
	TimeLimitType20 TimeLimitType = "20"
	TimeLimitType45 TimeLimitType = "45"
	TimeLimitType80 TimeLimitType = "80"
)

func (e *TimeLimitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TimeLimitType(s)
	case string:
		*e = TimeLimitType(s)
	default:
		return fmt.Errorf("unsupported scan type for TimeLimitType: %T", src)
	}
	return nil
}

type NullTimeLimitType struct {
	TimeLimitType TimeLimitType `json:"time_limit_type"`
	Valid         bool          `json:"valid"` // Valid is true if TimeLimitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTimeLimitType) Scan(value interface{}) error {
	if value == nil {
		ns.TimeLimitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TimeLimitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTimeLimitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TimeLimitType), nil
}

func (e TimeLimitType) Valid() bool {
	switch e {
	case TimeLimitType5,
		TimeLimitType10,
		TimeLimitType20,
		TimeLimitType45,
		TimeLimitType80:
		return true
	}
	return false
}

type Question struct {
	ID        int64              `json:"id"`
	QuizID    int64              `json:"quiz_id"`
	Question  string             `json:"question"`
	Type      QuestionType       `json:"type"`
	Answers   []byte             `json:"answers"`
	TimeLimit TimeLimitType      `json:"time_limit"`
	Index     int32              `json:"index"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

type Quiz struct {
	ID                   int64              `json:"id"`
	Title                string             `json:"title"`
	Description          *string            `json:"description"`
	OwnerID              int64              `json:"owner_id"`
	Visibility           QuizVisibility     `json:"visibility"`
	Slug                 *string            `json:"slug"`
	ViewCount            int32              `json:"view_count"`
	PlayCount            int32              `json:"play_count"`
	MaxParticipants      *int32             `json:"max_participants"`
	CurrentQuestionIndex int32              `json:"current_question_index"`
	TotalQuestions       *int32             `json:"total_questions"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	PublishedAt          pgtype.Timestamptz `json:"published_at"`
}

type QuizSession struct {
	ID                   int64              `json:"id"`
	QuizID               int64              `json:"quiz_id"`
	HostID               *int64             `json:"host_id"`
	JoinCode             string             `json:"join_code"`
	Status               SessionStatus      `json:"status"`
	CurrentQuestionIndex int32              `json:"current_question_index"`
	MaxParticipants      *int32             `json:"max_participants"`
	ParticipantCount     int32              `json:"participant_count"`
	StartedAt            pgtype.Timestamptz `json:"started_at"`
	EndedAt              pgtype.Timestamptz `json:"ended_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type SessionParticipant struct {
	ID           int64              `json:"id"`
	SessionID    int64              `json:"session_id"`
	UserID       *int64             `json:"user_id"`
	Nickname     string             `json:"nickname"`
	Score        int32              `json:"score"`
	IsHost       bool               `json:"is_host"`
	JoinedAt     pgtype.Timestamptz `json:"joined_at"`
	LastActivity pgtype.Timestamptz `json:"last_activity"`
}

type User struct {
	ID          int64              `json:"id"`
	Username    string             `json:"username"`
	Email       string             `json:"email"`
	Password    string             `json:"password"`
	AvatarUrl   *string            `json:"avatar_url"`
	IsActive    bool               `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt pgtype.Timestamptz `json:"last_login_at"`
}
