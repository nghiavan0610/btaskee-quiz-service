// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: session.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipant = `-- name: AddParticipant :one
INSERT INTO session_participants (
    session_id, user_id, nickname, score, is_host
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, session_id, user_id, nickname, score, is_host, joined_at, last_activity
`

type AddParticipantParams struct {
	SessionID int64  `json:"session_id"`
	UserID    *int64 `json:"user_id"`
	Nickname  string `json:"nickname"`
	Score     int32  `json:"score"`
	IsHost    bool   `json:"is_host"`
}

func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) (SessionParticipant, error) {
	row := q.db.QueryRow(ctx, addParticipant,
		arg.SessionID,
		arg.UserID,
		arg.Nickname,
		arg.Score,
		arg.IsHost,
	)
	var i SessionParticipant
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Nickname,
		&i.Score,
		&i.IsHost,
		&i.JoinedAt,
		&i.LastActivity,
	)
	return i, err
}

const checkJoinCodeExists = `-- name: CheckJoinCodeExists :one
SELECT EXISTS(SELECT 1 FROM quiz_sessions WHERE join_code = $1)
`

func (q *Queries) CheckJoinCodeExists(ctx context.Context, joinCode string) (bool, error) {
	row := q.db.QueryRow(ctx, checkJoinCodeExists, joinCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO quiz_sessions (
    quiz_id, host_id, join_code, status, max_participants,
    current_question_index, participant_count
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, quiz_id, host_id, join_code, status, current_question_index, max_participants, participant_count, started_at, ended_at, created_at, updated_at
`

type CreateSessionParams struct {
	QuizID               int64         `json:"quiz_id"`
	HostID               *int64        `json:"host_id"`
	JoinCode             string        `json:"join_code"`
	Status               SessionStatus `json:"status"`
	MaxParticipants      *int32        `json:"max_participants"`
	CurrentQuestionIndex int32         `json:"current_question_index"`
	ParticipantCount     int32         `json:"participant_count"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (QuizSession, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.QuizID,
		arg.HostID,
		arg.JoinCode,
		arg.Status,
		arg.MaxParticipants,
		arg.CurrentQuestionIndex,
		arg.ParticipantCount,
	)
	var i QuizSession
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.HostID,
		&i.JoinCode,
		&i.Status,
		&i.CurrentQuestionIndex,
		&i.MaxParticipants,
		&i.ParticipantCount,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const endSession = `-- name: EndSession :exec
UPDATE quiz_sessions 
SET 
    status = 'completed',
    ended_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND status = 'active'
`

func (q *Queries) EndSession(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, endSession, id)
	return err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT 
    s.id, s.quiz_id, s.host_id, s.join_code, s.status, s.current_question_index, s.max_participants, s.participant_count, s.started_at, s.ended_at, s.created_at, s.updated_at,
    q.title as quiz_title,
    q.description as quiz_description,
    q.total_questions as quiz_total_questions
FROM quiz_sessions s
JOIN quizzes q ON s.quiz_id = q.id
WHERE s.id = $1
`

type GetSessionByIDRow struct {
	ID                   int64              `json:"id"`
	QuizID               int64              `json:"quiz_id"`
	HostID               *int64             `json:"host_id"`
	JoinCode             string             `json:"join_code"`
	Status               SessionStatus      `json:"status"`
	CurrentQuestionIndex int32              `json:"current_question_index"`
	MaxParticipants      *int32             `json:"max_participants"`
	ParticipantCount     int32              `json:"participant_count"`
	StartedAt            pgtype.Timestamptz `json:"started_at"`
	EndedAt              pgtype.Timestamptz `json:"ended_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	QuizTitle            string             `json:"quiz_title"`
	QuizDescription      *string            `json:"quiz_description"`
	QuizTotalQuestions   *int32             `json:"quiz_total_questions"`
}

func (q *Queries) GetSessionByID(ctx context.Context, id int64) (GetSessionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i GetSessionByIDRow
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.HostID,
		&i.JoinCode,
		&i.Status,
		&i.CurrentQuestionIndex,
		&i.MaxParticipants,
		&i.ParticipantCount,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.QuizTitle,
		&i.QuizDescription,
		&i.QuizTotalQuestions,
	)
	return i, err
}

const getSessionByJoinCode = `-- name: GetSessionByJoinCode :one
SELECT 
    s.id, s.quiz_id, s.host_id, s.join_code, s.status, s.current_question_index, s.max_participants, s.participant_count, s.started_at, s.ended_at, s.created_at, s.updated_at,
    q.title as quiz_title,
    q.description as quiz_description,
    q.total_questions as quiz_total_questions
FROM quiz_sessions s
JOIN quizzes q ON s.quiz_id = q.id
WHERE s.join_code = $1
`

type GetSessionByJoinCodeRow struct {
	ID                   int64              `json:"id"`
	QuizID               int64              `json:"quiz_id"`
	HostID               *int64             `json:"host_id"`
	JoinCode             string             `json:"join_code"`
	Status               SessionStatus      `json:"status"`
	CurrentQuestionIndex int32              `json:"current_question_index"`
	MaxParticipants      *int32             `json:"max_participants"`
	ParticipantCount     int32              `json:"participant_count"`
	StartedAt            pgtype.Timestamptz `json:"started_at"`
	EndedAt              pgtype.Timestamptz `json:"ended_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	QuizTitle            string             `json:"quiz_title"`
	QuizDescription      *string            `json:"quiz_description"`
	QuizTotalQuestions   *int32             `json:"quiz_total_questions"`
}

func (q *Queries) GetSessionByJoinCode(ctx context.Context, joinCode string) (GetSessionByJoinCodeRow, error) {
	row := q.db.QueryRow(ctx, getSessionByJoinCode, joinCode)
	var i GetSessionByJoinCodeRow
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.HostID,
		&i.JoinCode,
		&i.Status,
		&i.CurrentQuestionIndex,
		&i.MaxParticipants,
		&i.ParticipantCount,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.QuizTitle,
		&i.QuizDescription,
		&i.QuizTotalQuestions,
	)
	return i, err
}

const getSessionLeaderboard = `-- name: GetSessionLeaderboard :many
SELECT 
    id,
    nickname,
    score,
    is_host,
    ROW_NUMBER() OVER (ORDER BY score DESC, joined_at ASC) as rank
FROM session_participants
WHERE session_id = $1
ORDER BY score DESC, joined_at ASC
`

type GetSessionLeaderboardRow struct {
	ID       int64  `json:"id"`
	Nickname string `json:"nickname"`
	Score    int32  `json:"score"`
	IsHost   bool   `json:"is_host"`
	Rank     int64  `json:"rank"`
}

func (q *Queries) GetSessionLeaderboard(ctx context.Context, sessionID int64) ([]GetSessionLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getSessionLeaderboard, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionLeaderboardRow{}
	for rows.Next() {
		var i GetSessionLeaderboardRow
		if err := rows.Scan(
			&i.ID,
			&i.Nickname,
			&i.Score,
			&i.IsHost,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionParticipants = `-- name: GetSessionParticipants :many
SELECT id, session_id, user_id, nickname, score, is_host, joined_at, last_activity FROM session_participants
WHERE session_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) GetSessionParticipants(ctx context.Context, sessionID int64) ([]SessionParticipant, error) {
	rows, err := q.db.Query(ctx, getSessionParticipants, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionParticipant{}
	for rows.Next() {
		var i SessionParticipant
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.Nickname,
			&i.Score,
			&i.IsHost,
			&i.JoinedAt,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startSession = `-- name: StartSession :exec
UPDATE quiz_sessions 
SET 
    status = 'active',
    started_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND status = 'waiting'
`

func (q *Queries) StartSession(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, startSession, id)
	return err
}

const updateParticipantScore = `-- name: UpdateParticipantScore :exec
UPDATE session_participants 
SET 
    score = score + $2,  -- Add to existing score for real-time updates
    last_activity = NOW()
WHERE id = $1
`

type UpdateParticipantScoreParams struct {
	ID    int64 `json:"id"`
	Score int32 `json:"score"`
}

func (q *Queries) UpdateParticipantScore(ctx context.Context, arg UpdateParticipantScoreParams) error {
	_, err := q.db.Exec(ctx, updateParticipantScore, arg.ID, arg.Score)
	return err
}

const updateSession = `-- name: UpdateSession :one
UPDATE quiz_sessions 
SET 
    status = $2,
    current_question_index = $3,
    max_participants = $4,
    participant_count = $5,
    started_at = $6,
    ended_at = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, quiz_id, host_id, join_code, status, current_question_index, max_participants, participant_count, started_at, ended_at, created_at, updated_at
`

type UpdateSessionParams struct {
	ID                   int64              `json:"id"`
	Status               SessionStatus      `json:"status"`
	CurrentQuestionIndex int32              `json:"current_question_index"`
	MaxParticipants      *int32             `json:"max_participants"`
	ParticipantCount     int32              `json:"participant_count"`
	StartedAt            pgtype.Timestamptz `json:"started_at"`
	EndedAt              pgtype.Timestamptz `json:"ended_at"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (QuizSession, error) {
	row := q.db.QueryRow(ctx, updateSession,
		arg.ID,
		arg.Status,
		arg.CurrentQuestionIndex,
		arg.MaxParticipants,
		arg.ParticipantCount,
		arg.StartedAt,
		arg.EndedAt,
	)
	var i QuizSession
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.HostID,
		&i.JoinCode,
		&i.Status,
		&i.CurrentQuestionIndex,
		&i.MaxParticipants,
		&i.ParticipantCount,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionQuestion = `-- name: UpdateSessionQuestion :exec
UPDATE quiz_sessions 
SET 
    current_question_index = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSessionQuestionParams struct {
	ID                   int64 `json:"id"`
	CurrentQuestionIndex int32 `json:"current_question_index"`
}

func (q *Queries) UpdateSessionQuestion(ctx context.Context, arg UpdateSessionQuestionParams) error {
	_, err := q.db.Exec(ctx, updateSessionQuestion, arg.ID, arg.CurrentQuestionIndex)
	return err
}
